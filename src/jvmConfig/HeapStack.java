package jvmConfig;

public class HeapStack {

    /*
    Java堆空间
    Java运行时使用Java堆空间将内存分配给Objects和JRE类。每当我们创建对象时，它总是在堆空间中创建。

    垃圾回收在堆内存上运行以释放没有任何引用的对象使用的内存。在堆空间中创建的任何对象都具有全局访问权限，并且可以从应用程序的任何位置进行引用。

    Java堆栈内存
    Java Stack内存用于执行线程。它们包含短期的特定于方法的值以及对从该方法引用的堆中其他对象的引用。

    堆栈存储器始终按LIFO（后进先出）顺序引用。每当调用方法时，都会在堆栈存储器中创建一个新块，以容纳该方法的本地原始值并引用该方法中的其他对象。

    方法结束后，该块将立即变为未使用状态，并可用于下一个方法。
    与堆内存相比，堆栈内存的大小要小得多。

    Java程序中的堆和堆栈内存
    让我们通过一个简单的程序来了解堆和堆栈的内存使用情况。


    package com.journaldev.test;

    public class Memory {

        public static void main(String[] args) { // Line 1
            int i=1; // Line 2
            Object obj = new Object(); // Line 3
            Memory mem = new Memory(); // Line 4
            mem.foo(obj); // Line 5
        } // Line 9

        private void foo(Object param) { // Line 6
            String str = param.toString(); //// Line 7
            System.out.println(str);
        } // Line 8

    }

    “堆内存和堆栈内存的区别”图片展示了上边程序堆和栈内存的引用，并且是怎么用来存储原始值、对象和变量的引用。

    我们来看看程序执行的过程：
    1、只要我们一运行这个程序，它会加载所有的运行类到堆内存中去，当在第一行找到main()方法的时候，Java创建可以被main()方法线程使用的栈内存。
    2、当在第一行，我们创建了本地原始变量，它在main()的栈中创建和保存。
    3、因为我们在第三行创建了对象，它在堆内存中被创建，在栈内存中保存了它的引用，同样的过程也发生在第四行我们创建Memory对象的时候。
    4、当在第五行我们调用foo()方法的时候，在堆的顶部创建了一个块来被foo()方法使用，因为Java是值传递的，在第六行一个新的对象的引用在foo()方法中的栈中被创建
    5、在第七行一个String被创建，它在堆空间中的String池中运行，并且它的引用也在foo()方法的栈空间中被创建
    6、foo()方法在第八行结束，此时在堆中为foo()方法分配的内存块可以被释放
    7、在第九行，main()方法结束，栈为main()方法创建的内存空间可以被销毁。同样程序也在行结束，Java释放了所有的内存，结束了程序的运行
    堆内存和栈内存的区别
    基于上边的解释我们可以很简单的总结出堆和栈的区别：
    1、应用程序所有的部分都使用堆内存，然后栈内存通过一个线程运行来使用。
    2、不论对象什么时候创建，他都会存储在堆内存中，栈内存包含它的引用。栈内存只包含原始值变量好和堆中对象变量的引用。
    3、存储在堆中的对象是全局可以被访问的，然而栈内存不能被其他线程所访问。
    4、栈中的内存管理使用LIFO的方式完成，而堆内存的管理要更复杂了，因为它是全局被访问的。堆内存被分为，年轻一代，老一代等等，更多的细节请看，这篇文章
    5、栈内存是生命周期很短的，然而堆内存的生命周期从程序的运行开始到运行结束。
    6、我们可以使用-Xms和-Xmx JVM选项定义开始的大小和堆内存的最大值，我们可以使用-Xss定义栈的大小
    7、当栈内存满的时候，Java抛出java.lang.StackOverFlowError异常而堆内存满的时候抛出java.lang.OutOfMemoryError: Java Heap Space错误
    8、和堆内存比，栈内存要小的多，因为明确使用了内存分配规则（LIFO），和堆内存相比栈内存非常快。

    让我们看一下程序执行的步骤。

    一旦运行程序，它将所有运行时类加载到堆空间中。在第1行找到main（）方法时，Java Runtime将创建要由main（）方法线程使用的堆栈内存。
    我们在第2行创建原始的局部变量，因此将其创建并存储在main（）方法的堆栈存储器中。
    由于我们是在第三行中创建一个对象，因此将在堆内存中创建该对象，而堆栈内存将包含该对象的引用。当我们在第四行中创建Memory对象时，也会发生类似的过程。
    现在，当我们在第5行调用foo（）方法时，将在堆栈顶部创建一个块，以供foo（）方法使用。由于Java是按值传递的，因此在第六行的foo（）堆栈块中创建了对Object的新引用。
    在第7行创建一个字符串，该字符串进入堆空间的“ 字符串池”，并在foo（）堆栈空间中为其创建引用。
    foo（）方法在第8行终止，这时为堆栈中的foo（）分配的内存块变为可用。
    在第9行中，main（）方法终止，并且为main（）方法创建的堆栈存储器被销毁。而且，程序在此行结束，因此Java Runtime释放了所有内存并结束了程序的执行。
    Java堆空间和堆栈内存之间的区别
    根据以上解释，我们可以轻松得出Heap和Stack内存之间的以下差异。

    堆内存由应用程序的所有部分使用，而堆栈内存仅由一个执行线程使用。
    每当创建对象时，它始终存储在堆空间中，并且堆栈存储器包含对该对象的引用。堆栈内存仅包含局部原始变量和堆空间中对象的引用变量。
    堆中存储的对象可以全局访问，而其他线程则不能访问堆栈内存。
    堆栈中的内存管理以LIFO方式完成，而在Heap内存中则更为复杂，因为它在全球范围内使用。堆内存分为Young-Generation，Old-Generation等，有关更多信息，请参见Java Garbage Collection。
    堆栈内存是短暂的，而堆内存是从应用程序执行的开始一直到结束。
    我们可以使用-Xms和-Xmx JVM选项来定义启动大小和堆内存的最大大小。我们可以使用-Xss定义堆栈内存大小。
    当堆栈内存已满时，Java运行时将引发，java.lang.StackOverFlowError而如果堆内存已满，则将引发java.lang.OutOfMemoryError: Java Heap Space错误。
    与堆内存相比，堆栈内存的大小要小得多。由于内存分配（LIFO）的简单性，与堆内存相比，堆栈内存非常快

     */
    public static void main(String[] args) {

    }
}
